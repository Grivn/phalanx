package executor

import (
	"fmt"

	"github.com/Grivn/phalanx/common/protos"
)

// sortableTimestamps is a sortable slice for free will trusted timestamp generation.
type sortableTimestamps []int64
func (ts sortableTimestamps) Len() int           { return len(ts) }
func (ts sortableTimestamps) Less(i, j int) bool { return ts[i] < ts[j] }
func (ts sortableTimestamps) Swap(i, j int)      { ts[i], ts[j] = ts[j], ts[i] }

type commandInfo struct {
	// curCmd is used to record the digest of current command.
	curCmd string

	// priCmd is used to track the digests of the command which should be executed before current command.
	priCmd map[string]bool

	// lowCmd is used to record the lowest partial-order which could be regarded as the lead item for current node.
	lowCmd map[string]*commandInfo

	// pOrders is used to record the partial-order generated by phalanx replicas.
	pOrders map[uint64]*protos.PartialOrder

	// timestamps is used to record the timestamp of partial orders.
	timestamps sortableTimestamps

	// trusted indicates if we have checked the potential priori command for it.
	trusted bool
}

func newCmdInfo(commandD string) *commandInfo {
	return &commandInfo{
		curCmd:  commandD,
		priCmd:  make(map[string]bool),
		lowCmd:  make(map[string]*commandInfo),
		pOrders: make(map[uint64]*protos.PartialOrder),
		trusted: false,
	}
}

func (ci *commandInfo) format() string {
	return fmt.Sprintf("[CommandInfo: command %s, order-count %d]", ci.curCmd, len(ci.pOrders))
}

func (ci *commandInfo) pOrderAppend(pOrder *protos.PartialOrder) {
	ci.pOrders[pOrder.Author()] = pOrder
	ci.timestamps = append(ci.timestamps, pOrder.Timestamp())
}

func (ci *commandInfo) pOrderCount() int {
	return len(ci.pOrders)
}

func (ci *commandInfo) prioriRecord(priInfo *commandInfo) {
	ci.priCmd[priInfo.curCmd] = true
}

func (ci *commandInfo) prioriAppend(priInfo *commandInfo) []string {
	var priorities []string

	ci.priCmd[priInfo.curCmd] = true
	priorities = append(priorities, priInfo.curCmd)

	for digest := range priInfo.priCmd {
		ci.priCmd[digest] = true
		priorities = append(priorities, digest)
	}

	for digest, info := range priInfo.lowCmd {
		ci.lowCmd[digest] = info
	}

	return priorities
}

func (ci *commandInfo) prioriCommit(commandD string) {
	delete(ci.priCmd, commandD)
}

func (ci *commandInfo) prioriFinished() bool {
	return len(ci.priCmd) == 0
}

//=========================== low command ====================================

func (ci *commandInfo) appendLow(info *commandInfo) {
	// append partial order into our lowest map.
	ci.lowCmd[info.curCmd] = info
}

// transitiveLow update current node's lowest map.
// <x,y> && <y,z> -> <x,z>
func (ci *commandInfo) transitiveLow(parentInfo *commandInfo) {
	// remove the parent partial order from lowest map.
	delete(ci.lowCmd, parentInfo.curCmd)

	// append parent's lowest into ourselves.
	for _, info := range parentInfo.lowCmd {
		ci.appendLow(info)
	}
}

type scanner struct {
	target string

	selfInfo *commandInfo

	found bool
}

func newScanner(info *commandInfo) *scanner {
	return &scanner{target: info.curCmd, selfInfo: info, found: false}
}

func (s *scanner) scan() bool {
	s.searchLowest(s.selfInfo)

	return s.found
}

func (s *scanner) searchLowest(info *commandInfo) map[string]*commandInfo {
	if s.found {
		return nil
	}

	if len(info.lowCmd) == 0 {
		// here is a leaf node, return the value
		return nil
	}

	for _, pInfo := range info.lowCmd {
		if pInfo.curCmd == s.target {
			// we have found target node, directly finish.
			s.found = true
			break
		}

		pLow := s.searchLowest(pInfo)

		if len(pLow) == 0 {
			continue
		}

		info.transitiveLow(pInfo)
	}

	return info.lowCmd
}
