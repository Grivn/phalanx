package executor

import (
	"fmt"

	"github.com/Grivn/phalanx/common/protos"
	"github.com/Grivn/phalanx/common/types"
)

type ExecutionRule interface {
	TryExecution(cmd *protos.Command, qc *protos.QuorumCert) []*types.Block
}

type executionRule struct {
	// fault indicates the upper limit for byzantine nodes.
	fault int

	// oneQuorum indicates there is at least one correct replica.
	oneQuorum int

	// quorum indicates the legal size for bft.
	quorum int

	commandSets map[string]*commandInfo

	// oneQuorumSet indicates there is at least one value in current set is generated by correct replica, e.g. f+1.
	oneQuorumSet map[string]bool

	// allQuorumSet indicates current set could be used to decide the final order for transactions, e.g. 2f+1.
	allQuorumSet map[string]bool

	committedCmd map[string]bool
}

func newExecutionRule(n int) *executionRule {
	return &executionRule{
		fault:        types.CalculateFault(n),
		oneQuorum:    types.CalculateOneQuorum(n),
		quorum:       types.CalculateQuorum(n),
		commandSets:  make(map[string]*commandInfo),
		oneQuorumSet: make(map[string]bool),
		allQuorumSet: make(map[string]bool),
		committedCmd: make(map[string]bool),
	}
}

func (er *executionRule) TryExecution(cmd *protos.Command, pOrder *protos.PartialOrder) []*types.Block {
	set, ok := er.commandSets[pOrder.CommandDigest()]
	if !ok {
		set = newCmdSet(cmd)
		er.commandSets[pOrder.CommandDigest()] = set
	}

	set.append(pOrder)

	if set.count() < er.oneQuorum {
		return nil
	}

	if set.count() == er.oneQuorum {
		er.oneQuorumSet[pOrder.CommandDigest()] = true
	}

	if set.count() == er.quorum {
		delete(er.oneQuorumSet, pOrder.CommandDigest())
		er.allQuorumSet[pOrder.CommandDigest()] = true
	}

	return nil
}

func (er *executionRule) quorumExecution() ([]*commandInfo, error) {
	var execution []*commandInfo
	for quorumD := range er.allQuorumSet {
		quorumSet, ok := er.commandSets[quorumD]
		if !ok {
			return nil, fmt.Errorf("execution failed: cannot find command %s", quorumD)
		}

		flag, err := er.quorumPriori(quorumSet)

		if err != nil {
			return nil, fmt.Errorf("execution failed: %s", err)
		}

		if flag {
			execution = append(execution, quorumSet)
		}
	}

	return execution, nil
}

func (er *executionRule) quorumPriori(quorumSet *commandInfo) (bool, error) {
	//for correctD := range er.oneQuorumSet {
	//	correctSet, ok := er.commandSets[correctD]
	//	if !ok {
	//		return false, fmt.Errorf("cannot find command %s", correctD)
	//	}
	//}
	return false, nil
}
