syntax = "proto3";

package protos;

//======================================================
//             transaction message
//======================================================

message Transaction {
  string hash = 1;
  bytes payload = 2;
}

message batch_id {
  uint64 author = 1;
  string batch_hash = 2;
}

message batch {
  batch_id batch_id = 1;
  repeated string hash_list = 2;
  repeated Transaction tx_list = 3;
  int64 timestamp = 4;
}

//======================================================
//                 structure in tx-pool
//======================================================

// TxBatch could be generated by everyone in phalanx cluster and it is constructed
// by the transactions we have received from api.
message TxBatch {
  // Digest indicates the identifier for current batch.
  string Digest = 1;
  // TxList indicates the transactions in current batch.
  repeated Transaction TxList = 2;
  repeated string HashList = 3;
}

//======================================================
//                 phalanx receiver
//======================================================

// Entry is a structure for one instruction
message Entry {
  // Hash is the identifier for current instruction.
  string Hash = 1;
  // Payload is the content for current instruction.
  bytes Payload = 2;
}

// Command is the thing we receive from others.
message Command {
  // Digest indicates the identifier for current command.
  string Digest = 1;
  // Content indicates the instructions in current command.
  repeated Entry Content = 2;
  // HashList is the list of instructions in current command.
  repeated string HashList = 3;
}

//======================================================
//                 proposal phase
//======================================================

// Proposal could be generated by everyone in phalanx cluster, it should have a particular
// sequence number for current node, and the batch information will be sent with proposal.
message Proposal {
  // Author indicates the generator of current proposal.
  uint64 Author = 1;
  // Sequence indicates the order of proposal for current node.
  uint64 Sequence = 2;
  // TxBatch contains the transactions to propose.
  TxBatch TxBatch = 3;
}

//======================================================
//                 order phase
//======================================================

// PreOrder is used to notify others the log order of current node.
message PreOrder {
  // Digest is the identifier of current pre-ordering protocol message, digest = Hash(author, sequence, batch-digest).
  string Digest = 1;
  // Author indicates the identifier of current node.
  uint64 Author = 2;
  // Sequence indicates the order of current log.
  uint64 Sequence = 3;
  // BatchDigest is the digest of tx-batch which is the content of current log.
  string BatchDigest = 4;
  // Timestamp indicates the time when current node generated such a log.
  int64 Timestamp = 5;
}

// Certification is used to verify the pre-ordering message on one node.
message Certification {
  // Signatures are the proof information which is generated by current node, signatures = SIGN(digest).
  repeated bytes Signatures = 1;
}

// Vote is generated by the replica who has received pre-ordering message to determine
// the pre-ordering message valid or not.
message Vote {
  // Author indicates the identifier of current node who has generated vote message.
  uint64 Author = 1;
  // Digest indicates the identifier of pre-ordering message which we have voted for.
  string Digest = 2;
  // Certification is the proof information which is generated by current node, signature = SIGN(digest).
  Certification Certification = 3;
}

// ProofCerts contains the signatures generated by participates which could verify the validation of current message.
message ProofCerts {
  // Certs are the signatures generated by others.
  map<uint64, Certification> Certs = 1;
}

// QuorumCert is an verified log order which would be generated by the node to notify others its log order
// when it has received efficient votes from other participates.
message QuorumCert {
  // PreOrder is the message we would like to send a quorum certification.
  PreOrder PreOrder = 1;
  // ProofCerts is a proof for pre-order.
  ProofCerts ProofCerts = 2;
}

//======================================================
//                 quorum certification
//======================================================

message QCFilter {
  repeated QuorumCert QCs = 1;
}

message QCBatch {
   repeated QCFilter Filters = 1;
   map<string, Command> Commands = 2;
}

//======================================================
//                 ordered message
//======================================================
message ordered_req {
  uint64 author = 1;
  uint64 sequence = 2;
  batch_id batch_id = 3;
  int64 timestamp = 4;
}

message ordered_log {
  uint64 author = 1;
  uint64 sequence = 2;
  batch_id batch_id = 3;
  int64 timestamp = 4;
}

message ordered_ack {
  uint64 author = 1;
  ordered_log ordered_log = 2;
}

//======================================================
//             communicate message
//======================================================

enum comm_type {
  BATCH = 0;
  LOG = 1;
  ACK = 2;
  REQ = 3;
}

message comm_msg {
  uint64 author = 1;
  comm_type type = 2;
  bytes payload = 3;
}

//
message execute_logs {
  uint64 sequence = 1;
  repeated ordered_log ordered_logs = 2;
}