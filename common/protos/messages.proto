syntax = "proto3";

package protos;

//======================================================
//             transaction message
//======================================================

message Transaction {
  string hash = 1;
  bytes payload = 2;
}

message batch_id {
  uint64 author = 1;
  string batch_hash = 2;
}

message batch {
  batch_id batch_id = 1;
  repeated string hash_list = 2;
  repeated Transaction tx_list = 3;
  int64 timestamp = 4;
}

//======================================================
//                 proposal phase
//======================================================

// TxBatch could be generated by everyone in phalanx cluster and it is constructed
// by the transactions we have received from api.
message TxBatch {
  // Digest indicates the identifier for current batch.
  string Digest = 1;
  // TxList indicates the transactions in current batch.
  repeated Transaction TxList = 2;
}

// Proposal could be generated by everyone in phalanx cluster, it should have a particular
// sequence number for current node, and the batch information will be sent with proposal.
message Proposal {
  // Author indicates the generator of current proposal.
  uint64 Author = 1;
  // Sequence indicates the order of proposal for current node.
  uint64 Sequence = 2;
  // TxBatch contains the transactions to propose.
  TxBatch TxBatch = 3;
}

//======================================================
//                 order phase
//======================================================

// PreOrdering is used to notify others the log order of current node.
message PreOrdering {
  // Digest is the identifier of current pre-ordering protocol message, digest = Hash(author, sequence, batch-digest).
  string Digest = 1;
  // Author indicates the identifier of current node.
  uint64 Author = 2;
  // Sequence indicates the order of current log.
  uint64 Sequence = 3;
  // BatchDigest is the digest of tx-batch which is the content of current log.
  string BatchDigest = 4;
}

// Vote is generated by the replica who has received pre-ordering message to determine
// the pre-ordering message valid or not.
message Vote {
  // Author indicates the identifier of current node who has generated vote message.
  uint64 Author = 1;
  // Digest indicates the identifier of pre-ordering message which we have voted for.
  string Digest = 2;
  // Signature is the proof information which is generated by current node, signature = SIGN(digest).
  bytes Signature = 3;
}

// Ordering is an verified log order which would be generated by the node to notify others its log order
// when it has received efficient votes from other participates.
message Ordering {
  // PreOrdering is the message we would like to send a quorum certification.
  PreOrdering PreOrdering = 1;
  // QuorumCert is the proof for pre-ordering message, it's a slice of signatures received from others.
  map<string, bytes> QuorumCert = 2;
}

//======================================================
//                 ordered message
//======================================================
message ordered_req {
  uint64 author = 1;
  uint64 sequence = 2;
  batch_id batch_id = 3;
  int64 timestamp = 4;
}

message ordered_log {
  uint64 author = 1;
  uint64 sequence = 2;
  batch_id batch_id = 3;
  int64 timestamp = 4;
}

message ordered_ack {
  uint64 author = 1;
  ordered_log ordered_log = 2;
}

//======================================================
//             communicate message
//======================================================

enum comm_type {
  BATCH = 0;
  LOG = 1;
  ACK = 2;
  REQ = 3;
}

message comm_msg {
  uint64 author = 1;
  comm_type type = 2;
  bytes payload = 3;
}

//
message execute_logs {
  uint64 sequence = 1;
  repeated ordered_log ordered_logs = 2;
}