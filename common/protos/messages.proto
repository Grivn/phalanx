syntax = "proto3";

package protos;

//======================================================
//                 phalanx receiver
//======================================================

// Transaction is a structure for one instruction.
message Transaction {
  // Hash is the identifier.
  string Hash = 1;
  // Payload is the instruction content.
  bytes Payload = 2;
  // Timestamp is the time stamp for current transaction.
  int64 Timestamp = 3;
}

// Command is the meta data for consensus processor.
message Command {
  // Author is the identifier for the client.
  uint64 Author = 1;
  // Sequence indicates the sequence for current client.
  uint64 Sequence = 2;
  // Digest indicates the identifier for current command.
  string Digest = 3;
  // Content indicates the instructions in current command.
  repeated Transaction Content = 4;
  // HashList is the list of instructions in current command.
  repeated string HashList = 5;
  // GTime is the timestamp when command is generated.
  int64 GTime = 6;
  // FrontRunner is used to detect interval relationship front attack, metrics info.
  CommandProtoIndex FrontRunner = 7;
}

// CommandProtoIndex indicates the essential index info for command request.
message CommandProtoIndex {
  // Author indicates the generator current command.
  uint64 Author = 1;
  // Sequence indicates the sequence number for current command.
  uint64 Sequence = 2;
}

//======================================================
//                 consensus message
//======================================================

// MessageType indicates the type of messages.
enum MessageType {
  PRE_ORDER = 0;
  VOTE = 1;
  QUORUM_CERT = 2;
}

// ConsensusMessage is the raw consensus messages in real network.
message ConsensusMessage {
  // MessageType indicates the message type which could be used in unmarshal process.
  MessageType Type = 1;
  // From is the sender of current message.
  uint64 From = 2;
  // To is the receiver of current message, 0 means broadcast.
  uint64 To = 3;
  // Payload is the message content.
  bytes Payload = 4;
}

//======================================================
//                 order phase
//======================================================

// PreOrder is used to notify others the log order of current node.
message PreOrder {
  // Digest is the identifier of current pre-ordering protocol message, digest = Hash(author, sequence, batch-digest).
  string Digest = 1;
  // Author indicates the identifier of current node.
  uint64 Author = 2;
  // Sequence indicates the order of current log.
  uint64 Sequence = 3;
  // OrderedCommands is a slice indicates the receive-order of commands on current node.
  repeated string CommandList = 4;
  // Timestamp indicates the time when current node generated such a log.
  repeated int64 TimestampList = 5;
  // ParentDigest indicates the parent pre-order digest.
  string ParentDigest = 6;
}

// Certification is used to verify the pre-ordering message on one node.
message Certification {
  // Signatures are the proof information which is generated by current node, signatures = SIGN(digest).
  repeated bytes Signatures = 1;
}

// Vote is generated by the replica who has received pre-ordering message to determine
// the pre-ordering message valid or not.
message Vote {
  // Author indicates the identifier of current node who has generated vote message.
  uint64 Author = 1;
  // Digest indicates the identifier of pre-ordering message which we have voted for.
  string Digest = 2;
  // Certification is the proof information which is generated by current node, signature = SIGN(digest).
  Certification Certification = 3;
}

// QuorumCert contains the signatures generated by participates which could verify the validation of current message.
message QuorumCert {
  // Certs are the signatures generated by others.
  map<uint64, Certification> Certs = 1;
}

// PartialOrder is a verified log order generated by every node in phalanx cluster which is used to notify others its
// partial log order. it could be generated when current node has received efficient votes from other participates.
message PartialOrder {
  // PreOrder is the message we would like to send a quorum certification.
  PreOrder PreOrder = 1;
  // QC is a proof for current partial order.
  QuorumCert QC = 2;
  // OrderedTime records the timestamp when current partial order is generated.
  int64 OrderedTime = 3;
}

//======================================================
//                 quorum certification
//======================================================

// todo partial batch without map schema for that map has random hash order.

// PartialOrderBatch is used to collect the partial orders for bft consensus.
message PartialOrderBatch {
  // Author is the generator for current batch.
  uint64 Author = 1;
  // HighOrders are the high-order which the generator has observed for each participants,
  repeated PartialOrder HighOrders = 2;
  // SeqList indicates the sequence number for the high-order we have selected.
  repeated uint64 SeqList = 3;
}
