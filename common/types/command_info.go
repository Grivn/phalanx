package types

import (
	"fmt"

	"github.com/Grivn/phalanx/common/protos"
)

// sortableTimestamps is a sortable slice for free will trusted timestamp generation.
type sortableTimestamps []int64
func (ts sortableTimestamps) Len() int           { return len(ts) }
func (ts sortableTimestamps) Less(i, j int) bool { return ts[i] < ts[j] }
func (ts sortableTimestamps) Swap(i, j int)      { ts[i], ts[j] = ts[j], ts[i] }

type CommandInfo struct {
	// CurCmd is used to record the digest of current command.
	CurCmd string

	// PriCmd is used to track the digests of the command which should be executed before current command.
	PriCmd map[string]bool

	// LowCmd is used to record the lowest commands which could be regarded as the first priority command for us.
	LowCmd map[string]*CommandInfo

	// Orders is used to record the partial-order generated by phalanx replicas.
	Orders map[uint64]*protos.PartialOrder

	// Timestamps is used to record the timestamp of partial orders.
	Timestamps sortableTimestamps

	// Trust indicates if we have checked the potential priori command for it.
	Trust bool
}

func NewCmdInfo(commandD string) *CommandInfo {
	return &CommandInfo{
		CurCmd: commandD,
		PriCmd: make(map[string]bool),
		LowCmd: make(map[string]*CommandInfo),
		Orders: make(map[uint64]*protos.PartialOrder),
		Trust:  false,
	}
}

func (ci *CommandInfo) Format() string {
	return fmt.Sprintf("[CommandInfo: command %s, order-count %d]", ci.CurCmd, len(ci.Orders))
}

//========================== Partial Order Manager ====================================

func (ci *CommandInfo) OrderAppend(pOrder *protos.PartialOrder) {
	ci.Orders[pOrder.Author()] = pOrder
	ci.Timestamps = append(ci.Timestamps, pOrder.Timestamp())
}

func (ci *CommandInfo) OrderCount() int {
	return len(ci.Orders)
}

//========================== Priority Command ====================================

func (ci *CommandInfo) PrioriRecord(priInfo *CommandInfo) {
	ci.PriCmd[priInfo.CurCmd] = true
}

func (ci *CommandInfo) PrioriCommit(commandD string) {
	delete(ci.PriCmd, commandD)
}

func (ci *CommandInfo) PrioriFinished() bool {
	return len(ci.PriCmd) == 0
}

//=========================== Lowest Command ====================================

// TransitiveLow update current node's lowest map.
// <x,y> && <y,z> -> <x,z>
func (ci *CommandInfo) TransitiveLow(parentInfo *CommandInfo) {
	// remove the parent partial order from lowest map.
	delete(ci.LowCmd, parentInfo.CurCmd)

	// append parent's lowest into ourselves.
	for _, info := range parentInfo.LowCmd {
		ci.AppendLow(info)
	}
}

func (ci *CommandInfo) AppendLow(info *CommandInfo) {
	// append partial order into our lowest list.
	ci.LowCmd[info.CurCmd] = info
}
