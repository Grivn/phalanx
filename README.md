# Phalanx: An Asynchronous Order-Fairness Byzantine Consensus Protocol
[TOC]
## Introduction
Generally, a BFT (*Byzantine Fault Tolerance*) consensus algorithm concentrates on two properties, *safety* and *liveness*. 
Well, in the system on reality, we should also pay attention to the order of transactions, in which an incorrect order may make the tasks failed.
For instance, here is an instant commodity trading system. 
In such a system, we should send a *trading-transaction* for it if we would like to buy something.
After the process of this transaction, the commodity you prefer would be locked.
When only one consumer is trying to buy one commodity and sending *trading-transaction*, it is easy to process. 
But if there are several people trying to buy one thing at the same time, a concurrency problem will occur, 
and the order of *trading-transactions* could decide who the commodity belongs to.
In this situation, the order of transactions would be important for trading fairness.

With most BFT algorithm, especially the partially synchronous protocols, such as PBFT[[1]](#refer-anchor-1) [[2]](#refer-anchor-2) and HotStuff[[3]](#refer-anchor-3), 
we cannot deal with the problem about fairness of transaction order because of the proposal generation process.
In most BFT protocols, a proposal is usually generated by one specific node, and the participants could only detect
limited malicious manners of proposer, such as *fork-attack* or *silence-attack*. 
As the proposer could make a decision on the content of proposals, it could decide the order the 
transactions on purpose to make some of them failed, which cannot be detected as normal.

So that, in *CRYPTO2020*, [[4]](#refer-anchor-4) introduced a new kind of property for BFT called *order-fairness*, 
which indicates a trusted order for transactions. The author has also proposed a new class of consensus protocols called Aequitas, 
which are the first to achieve *order-fairness* in both *synchronous* and "asynchronous" situations. 
However, the Aequitas are difficult to implement, and there are not any experiments for the performance of them. 
To make it more practical, in *USENIX2020*, [[5]](#refer-anchor-5) proposed a consensus protocol
called Pompe, which could also achieve the *order-fairness* under the partially synchronous BFT protocols, 
and did some experiments on it. But it is difficult for us to use Pompe in asynchronous situation, 
as the order of commands in it is decided by *trusted-timestamp*.

So that, we propose a brand-new protocol called *Phalanx*. It is an order-fairness byzantine fault tolerance protocol 
to achieve *order-fairness* property. It could become a plugin for most kinds of BFT protocol, 
which means a traditional BFT protocol could complete the order-fairness property easily with the accession of *Phalanx*.
In addition, the Phalanx protocol could also be used in asynchronous situation, we have proposed *Async-Phalanx* to achieve it.

## Reference
<div id="refer-anchor-1"></div>
[1] Castro M, Liskov B. Practical byzantine fault tolerance[C]//OSDI. 1999, 99(1999): 173-186.
<div id="refer-anchor-2"></div>
[2] Castro M, Liskov B. Practical Byzantine fault tolerance and proactive recovery[J]. ACM Transactions on Computer Systems (TOCS), 2002, 20(4): 398-461.
<div id="refer-anchor-3"></div>
[3] Yin M, Malkhi D, Reiter M K, et al. Hotstuff: Bft consensus with linearity and responsiveness[C]//Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing. 2019: 347-356.
<div id="refer-anchor-4"></div>
[4] Kelkar M, Zhang F, Goldfeder S, et al. Order-fairness for byzantine consensus[C]//Annual International Cryptology Conference. Springer, Cham, 2020: 451-480.
<div id="refer-anchor-5"></div>
[5] Zhang Y, Setty S, Chen Q, et al. Byzantine Ordered Consensus without Byzantine Oligarchy[C]//14th {USENIX} Symposium on Operating Systems Design and Implementation ({OSDI} 20). 2020: 633-649.

## Background
The development of BFT protocols, the importance for order-fairness property, and some research on it.

## Phalanx Phase
### Overview

### Roles
#### Client
The client would like to execute *command* should broadcast it to all the replicas.

#### Replica
Every replica in phalanx cluster should maintain a *selfish-order* for the commands received from clients.
The replica itself should be responsible for the *selfish-order* that there wouldn't be any byzantine problems on it.

### RBC
A protocol to make sure the command from client could be sent for all the phalanx replicas.

### Selfish-Order Protocol
We can regard it as a fixed-leader BFT cluster in which we use a byzantine quorum system here to detect *fork-attack*.

#### Pre-Order
While receiving a command from clients, the replica will assign a specific sequence number for it 
and generate pre-order to notify other participants.
- <PRE-ORDER i, n, d, command-d, t>

#### Vote
While receiving a pre-order from other replica, verify it according to sequence number.
We should make sure that the sequence number is increasing one by one, and then, send a signed vote back if the pre-order is valid.
- <VOTE i, d, sig>

#### Order
The node waiting for quorum votes about its pre-order. If the votes has reached quorum size, aggregate them and generate
a quorum-cert (QC) for pre-order, and broadcast order message. The node received order message would store it by order.
- <ORDER i, n, d, command-d, t, QC>

### Synchronous Phalanx Interface
Interfaces for phalanx protocol that we could use them to make a traditional synchronous BFT protocol achieve *order-fairness* property.

#### Generator
It is used to generate a phalanx-proposal. 

Generate a proposal when there are at least f+1 replicas waiting for consensus-order that they have finished 
their own selfish-order. We would like to pull their first pending ordered log to make a consensus proposal.

#### Communicator
It is used to communicate with each other.

#### Validator
It is used for verification of phalanx order during normal BFT process.

Verify the QC-batch first. We should make sure that there are at least f+1 ordered logs in it. Then, we would like to 
verify each QC in QC-batch. A valid QC should have a correct aggregate signature. Besides, we should make sure the 
ordered logs in proposal have never been proposed before. At last, before trying to commit the proposal, we need to
check if the ordered logs in proposal commit by order. If not, refuse to commit them and put back the ordered logs.

Besides, if we start a phalanx service in chained bft, we could set stable QCs and check the order when the consensus
QC has reached 2-chained rule. It is because that the phalanx protocol is an asynchronous protocol. The rule of
3-chained in synchronous BFT protocol aims to prevent the liveness problem from GST assumption.

#### Executor
It is used to execute the phalanx-proposal after the BFT consensus. 

Generate a block when there are at least 2f+1 replicas' ordered log passing the consensus phase. If there are several 
commands reaching a quorum size at the same time, the order of them would be decided by trusted timestamp, which means 
the median number of timestamp in quorum set.

### Proof
Proof for properties, safety, liveness and order-fairness.
#### Safety
##### safety of selfish-order
Here, we need to collect 2f+1 votes from all the replicas, so that, the selfish order could not
make a fork.
##### safety of validator
The safety of validator is based on the BFT algorithm which we use in consensus process.

#### Liveness
##### liveness of selfish-order
##### liveness of validator

#### Order-Fairness
##### order-fairness
First, we should make sure that the all the correct transactions we send into cluster could be executed, 
and all the transactions which have been executed are valid.

Here, we would like to generate a consensus proposal when we have found f+1 replicas have a non-consensus QC.
It is because that in such a situation, there is at least one correct node waiting for common-order as it has 
finished its selfish-order. But we would like not to generate a block until there are 2f+1 replicas' order for
one command passing the consensus process. A 2f+1 set could make sure a correct command order (which could be 
proofed by contradiction). On the other hand, if there are several commands reach one block, a 2f+1 set could 
help us find the trusted timestamp to execute the command in correct order.
