package sequencepool

import (
	"errors"
	"fmt"
	"github.com/Grivn/phalanx/common/crypto"
	"github.com/Grivn/phalanx/common/protos"
	"github.com/Grivn/phalanx/common/types"
	"github.com/google/btree"
)

type qcReminder struct {
	// id is the identifier for current replica.
	id uint64

	// quorum indicates the legal size for stable-state.
	quorum int

	// cachedQCs are the QCs generated by current participate and haven't been used yet.
	cachedQCs *btree.BTree

	// verifiedQCs are the QCs which have been verified or proposed.
	verifiedQCs *btree.BTree

	// stableSeq indicates the latest sequence-number which has been verified by consensus module, init from 0.
	stableSeq uint64

	verifierSeq uint64
}

func newQCReminder(n int, id uint64) *qcReminder {
	return &qcReminder{id: id, quorum: types.CalculateQuorum(n), cachedQCs: btree.New(2), verifiedQCs: btree.New(2), stableSeq: uint64(0)}
}

// preprocess is an initialization for QC-reminder to process QCs.
func (qr *qcReminder) preprocess() {
	for {
		item := qr.verifiedQCs.Min()

		if item == nil {
			break
		}

		qr.cachedQCs.ReplaceOrInsert(item)
	}
}

// insert is used to store the QCs generated by current participate.
func (qr *qcReminder) insert(qc *protos.QuorumCert) error {
	if qc.Sequence() <= qr.stableSeq {
		return fmt.Errorf("expired sequence: stable %d, received %d", qr.stableSeq, qc.Sequence())
	}

	qr.cachedQCs.ReplaceOrInsert(qc)
	return nil
}

// verify is used to check the QC from remote participates when we are running a partial-synchronized byzantine consensus.
func (qr *qcReminder) verify(remoteQC *protos.QuorumCert) error {
	// todo we need initial data for correct stable-sequence

	// the remote QC shouldn't be nil.
	if remoteQC == nil {
		return errors.New("nil remote QC")
	}

	// the No of remoteQC should be sequentially increased.
	if remoteQC.Sequence() != qr.stableSeq+1 {
		return fmt.Errorf("invalid sequence: expected %d, received %d", qr.stableSeq+1, remoteQC.Sequence())
	}

	// the signature of QC should be valid.
	if err := crypto.VerifyProofCerts(types.StringToBytes(remoteQC.Digest()), remoteQC.ProofCerts, qr.quorum); err != nil {
		return fmt.Errorf("invalid QC signature: %s", err)
	}

	return nil
}

// pureCache is used to delete the QCs with expired sequence number in cache.
func (qr *qcReminder) pureCache(remoteQC *protos.QuorumCert) {
	for {
		qc := qr.cachedMin()

		// none QC here in QC-cache.
		if qc == nil {
			break
		}

		// QCs in cache have larger sequence than remoteQC.
		if qc.Sequence() > remoteQC.Sequence() {
			break
		}

		qr.cachedDelete(qc)
	}

	qr.verifiedQCs.ReplaceOrInsert(remoteQC)
}

// cachedMin is used to get the smallest QC from cache.
func (qr *qcReminder) cachedMin() *protos.QuorumCert {
	item := qr.cachedQCs.Min()

	if item == nil {
		return nil
	}

	return item.(*protos.QuorumCert)
}

// cachedDelete is used to delete the QC in cache.
func (qr *qcReminder) cachedDelete(qc *protos.QuorumCert) {
	qr.cachedQCs.Delete(qc)
}
