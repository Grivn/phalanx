package sequencepool

import (
	"errors"
	"fmt"
	"github.com/Grivn/phalanx/common/crypto"
	"github.com/Grivn/phalanx/common/protos"
	"github.com/Grivn/phalanx/common/types"
	"github.com/google/btree"
)

type qcReminder struct {
	author uint64

	// id is the identifier for current replica.
	id uint64

	// quorum indicates the legal size for stable-state.
	quorum int

	// cachedQCs are the QCs generated by current participate and haven't been used yet.
	cachedQCs *btree.BTree

	// lockedQCs are the QCs which have been verified or proposed.
	lockedQCs *btree.BTree

	// stableSeq indicates the latest sequence-number which has been verified by consensus module, init from 0.
	stableSeq uint64

	lockedSeq uint64
}

func newQCReminder(author uint64, n int, id uint64) *qcReminder {
	return &qcReminder{author: author, id: id, quorum: types.CalculateQuorum(n), cachedQCs: btree.New(2), lockedQCs: btree.New(2), stableSeq: uint64(0)}
}

// preprocess is an initialization for QC-reminder to process QCs.
func (qr *qcReminder) preprocess() {
	// restore the QCs from locked-QCs that they have not reached quorum status in byzantine consensus module.
	for {
		item := qr.lockedQCs.Min()

		if item == nil {
			break
		}

		if item.(*protos.QuorumCert).Sequence() < qr.stableSeq {
			continue
		}

		qr.cachedQCs.ReplaceOrInsert(item)
	}

	// init the locked sequence number for reminder to track the logs.
	qr.lockedSeq = qr.stableSeq
}

// insertQC is used to store the QCs generated by current participate.
func (qr *qcReminder) insertQC(qc *protos.QuorumCert) error {
	if qc.Sequence() <= qr.stableSeq {
		return fmt.Errorf("expired sequence: stable %d, received %d", qr.stableSeq, qc.Sequence())
	}

	qr.cachedQCs.ReplaceOrInsert(qc)
	return nil
}

// pullQC is used to pull the QCs to generate the payload for byzantine consensus module.
func (qr *qcReminder) pullQC() *protos.QuorumCert {
	minQC := qr.cachedMin()

	if minQC == nil {
		return nil
	}

	if minQC.Sequence() != qr.stableSeq+1 {
		return nil
	}

	return minQC
}

// stableQC is used to make the verified QCs stable, that we would like to update the stable sequence and remove the expired QCs.
func (qr *qcReminder) stableQC(qc *protos.QuorumCert) error {
	// check the validation of sequence number of stable-QC
	if qc.Sequence() <= qr.stableSeq {
		return fmt.Errorf("invalid stable sequence: current %d, received %d", qr.stableSeq, qc.Sequence())
	}

	// update the stable QC sequence number
	qr.stableSeq = qc.Sequence()

	// delete the expired cached-QCs
	for {
		minQC := qr.cachedMin()

		if minQC == nil {
			break
		}

		if minQC.Sequence() > qr.stableSeq {
			break
		}

		qr.cachedQCs.Delete(minQC)
	}

	// delete the expired locked-QCs
	for {
		minQC := qr.lockedDeleteMin()

		if minQC == nil {
			break
		}

		if minQC.Sequence() > qr.stableSeq {
			break
		}

		qr.lockedQCs.Delete(minQC)
	}

	return nil
}

// lockQC is used to lock the QCs which have been proposed.
func (qr *qcReminder) lockQC(qc *protos.QuorumCert) {
	// remove the QC from cache
	qr.cachedQCs.Delete(qc)

	// insertQC the QC into locked cache, which means the QC has been proposed but has not been verified by byzantine consensus module
	qr.lockedQCs.ReplaceOrInsert(qc)
}

// verify is used to check the QC from remote participates when we are running a partial-synchronized byzantine consensus.
func (qr *qcReminder) verify(remoteQC *protos.QuorumCert) error {
	// todo we need initial data for correct stable-sequence

	// the remote QC shouldn't be nil.
	if remoteQC == nil {
		return errors.New("nil remote QC")
	}

	// the No of remoteQC should be sequentially increased.
	if remoteQC.Sequence() != qr.lockedSeq+1 {
		return fmt.Errorf("invalid sequence: reminader %d, from %d, expected %d, received %d", qr.id, remoteQC.Author(), qr.stableSeq+1, remoteQC.Sequence())
	}

	// the signature of QC should be valid.
	if err := crypto.VerifyProofCerts(types.StringToBytes(remoteQC.Digest()), remoteQC.ProofCerts, qr.quorum); err != nil {
		return fmt.Errorf("invalid QC signature: %s", err)
	}

	qr.lockedSeq++

	return nil
}

// pureCache is used to delete the QCs with expired sequence number in cache.
func (qr *qcReminder) pureCache(remoteQC *protos.QuorumCert) {
	for {
		qc := qr.cachedDeleteMin()

		// none QC here in QC-cache.
		if qc == nil {
			break
		}

		// QCs in cache have larger sequence than remoteQC.
		if qc.Sequence() > remoteQC.Sequence() {
			qr.cachedQCs.ReplaceOrInsert(qc)
			break
		}
	}

	qr.lockedQCs.ReplaceOrInsert(remoteQC)
}

// cachedMin is used to get the smallest QC from cache.
func (qr *qcReminder) cachedMin() *protos.QuorumCert {
	item := qr.cachedQCs.Min()

	if item == nil {
		return nil
	}

	return item.(*protos.QuorumCert)
}

func (qr *qcReminder) cachedDeleteMin() *protos.QuorumCert {
	item := qr.cachedQCs.DeleteMin()

	if item == nil {
		return nil
	}

	return item.(*protos.QuorumCert)
}

// cachedDelete is used to delete the QC in cache.
func (qr *qcReminder) cachedDelete(qc *protos.QuorumCert) {
	qr.cachedQCs.Delete(qc)
}

// lockedMin is used to get the smallest QC from cache.
func (qr *qcReminder) lockedMin() *protos.QuorumCert {
	item := qr.lockedQCs.Min()

	if item == nil {
		return nil
	}

	return item.(*protos.QuorumCert)
}

func (qr *qcReminder) lockedDeleteMin() *protos.QuorumCert {
	item := qr.lockedQCs.DeleteMin()

	if item == nil {
		return nil
	}

	return item.(*protos.QuorumCert)
}

// lockedDelete is used to delete the QC in cache.
func (qr *qcReminder) lockedDelete(qc *protos.QuorumCert) {
	qr.lockedQCs.Delete(qc)
}
