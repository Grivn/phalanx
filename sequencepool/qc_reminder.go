package sequencepool

import (
	"errors"
	"fmt"
	"github.com/Grivn/phalanx/common/crypto"
	"github.com/Grivn/phalanx/common/protos"
	"github.com/Grivn/phalanx/common/types"
	"github.com/google/btree"
)

type qcReminder struct {
	author uint64

	// id is the identifier for current replica.
	id uint64

	// quorum indicates the legal size for stable-state.
	quorum int

	// cachedQCs is a cache for QCs that are generated by replicas and have not been proposed yet.
	cachedQCs *btree.BTree

	// proposedQCs is used to record the QCs which have been proposed.
	proposedQCs *btree.BTree

	//
	proposedNos map[uint64]bool

	// stableNo indicates the latest stable sequence-number.
	// stable sequence number: the number which has been verified by bft consensus module.
	stableNo uint64

	// proposedNo indicates the latest proposed sequence number.
	proposedNo uint64
}

func newQCReminder(author uint64, n int, id uint64) *qcReminder {
	return &qcReminder{author: author, id: id, quorum: types.CalculateQuorum(n), cachedQCs: btree.New(2), proposedQCs: btree.New(2)}
}

// restoreQCs is used to restore the QCs from proposed-QCs and remove these seqNo from proposed-Nos.
func (qr *qcReminder) restoreQCs() {
	// restore the QCs from proposedQCs.
	for {
		minQC := qr.lockedDeleteMin()

		if minQC == nil {
			break
		}

		if minQC.Sequence() < qr.stableNo {
			continue
		}

		qr.cachedQCs.ReplaceOrInsert(minQC)
	}

	// init the locked sequence number for reminder to track the logs.
	qr.proposedNo = qr.stableNo
}

// insertQC is used to store the QCs generated by current participate.
func (qr *qcReminder) insertQC(qc *protos.QuorumCert) error {
	if qc.Sequence() <= qr.stableNo {
		return fmt.Errorf("expired sequence: stable %d, received %d", qr.stableNo, qc.Sequence())
	}

	qr.cachedQCs.ReplaceOrInsert(qc)
	return nil
}

// pullQC is used to pull the QCs to generate the payload for byzantine consensus module.
func (qr *qcReminder) pullQC() *protos.QuorumCert {
	minQC := qr.cachedMin()

	if minQC == nil {
		return nil
	}

	if minQC.Sequence() != qr.stableNo+1 {
		return nil
	}

	return minQC
}

// stableQC is used to make the verified QCs stable, that we would like to update the stable sequence and remove the expired QCs.
func (qr *qcReminder) stableQC(qc *protos.QuorumCert) error {
	// check the validation of sequence number of stable-QC
	if qc.Sequence() <= qr.stableNo {
		return fmt.Errorf("invalid stable sequence: current %d, received %d", qr.stableNo, qc.Sequence())
	}

	// update the stable QC sequence number
	qr.stableNo = qc.Sequence()

	// delete the expired cached-QCs
	for {
		minQC := qr.cachedMin()

		if minQC == nil {
			break
		}

		if minQC.Sequence() > qr.stableNo {
			break
		}

		qr.cachedQCs.Delete(minQC)
	}

	// delete the expired locked-QCs
	for {
		minQC := qr.lockedMin()

		if minQC == nil {
			break
		}

		if minQC.Sequence() > qr.stableNo {
			break
		}

		qr.proposedQCs.Delete(minQC)
	}

	return nil
}

// verify is used to check the QC from remote participates when we are running a partial-synchronized byzantine consensus.
func (qr *qcReminder) verify(remoteQC *protos.QuorumCert) error {
	// todo we need initial data for correct stable-sequence

	// the remote QC shouldn't be nil.
	if remoteQC == nil {
		return errors.New("nil remote QC")
	}

	// the No of remoteQC should be sequentially increased.
	if remoteQC.Sequence() != qr.proposedNo+1 {
		return fmt.Errorf("invalid sequence: reminader %d, from %d, expected %d, received %d", qr.id, remoteQC.Author(), qr.stableNo+1, remoteQC.Sequence())
	}

	// the signature of QC should be valid.
	if err := crypto.VerifyProofCerts(types.StringToBytes(remoteQC.Digest()), remoteQC.ProofCerts, qr.quorum); err != nil {
		return fmt.Errorf("invalid QC signature: %s", err)
	}

	// update the
	qr.proposedNo++

	// pure the cache and record the proposed QC.
	qr.pureQC(remoteQC)

	return nil
}

// pureQC is used to remove the QCs with expired sequence from cache and record the proposed QC.
func (qr *qcReminder) pureQC(remoteQC *protos.QuorumCert) {
	for {
		minQC := qr.cachedMin()

		// none QC here in QC-cache.
		if minQC == nil {
			break
		}

		// QCs in cache have larger sequence than remoteQC.
		if minQC.Sequence() > remoteQC.Sequence() {
			break
		}

		qr.cachedDelete(minQC)
	}

	qr.proposedQCs.ReplaceOrInsert(remoteQC)
}

// cachedMin is used to get the smallest QC from cache.
func (qr *qcReminder) cachedMin() *protos.QuorumCert {
	item := qr.cachedQCs.Min()

	if item == nil {
		return nil
	}

	return item.(*protos.QuorumCert)
}

func (qr *qcReminder) cachedDeleteMin() *protos.QuorumCert {
	item := qr.cachedQCs.DeleteMin()

	if item == nil {
		return nil
	}

	return item.(*protos.QuorumCert)
}

// cachedDelete is used to delete the QC in cache.
func (qr *qcReminder) cachedDelete(qc *protos.QuorumCert) {
	qr.cachedQCs.Delete(qc)
}

// lockedMin is used to get the smallest QC from cache.
func (qr *qcReminder) lockedMin() *protos.QuorumCert {
	item := qr.proposedQCs.Min()

	if item == nil {
		return nil
	}

	return item.(*protos.QuorumCert)
}

func (qr *qcReminder) lockedDeleteMin() *protos.QuorumCert {
	item := qr.proposedQCs.DeleteMin()

	if item == nil {
		return nil
	}

	return item.(*protos.QuorumCert)
}

// lockedDelete is used to delete the QC in cache.
func (qr *qcReminder) lockedDelete(qc *protos.QuorumCert) {
	qr.proposedQCs.Delete(qc)
}
