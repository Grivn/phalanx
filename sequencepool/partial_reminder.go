package sequencepool

import (
	"errors"
	"fmt"

	"github.com/Grivn/phalanx/common/crypto"
	"github.com/Grivn/phalanx/common/protos"
	"github.com/Grivn/phalanx/common/types"

	"github.com/google/btree"
)

type partialReminder struct {
	// author indicates the identifier for current participate.
	author uint64

	// id is the identifier for current replica.
	id uint64

	// quorum indicates the legal size for bft.
	quorum int

	// cachedPartials is a cache for partial order that are generated by replicas and have not been proposed yet.
	cachedPartials *btree.BTree

	// proposedPartials is used to record the partial order which have been proposed.
	proposedPartials *btree.BTree

	// proposedNo is used to track the seqNo which has been proposed.
	proposedNo map[uint64]bool

	// stableNo indicates the latest stable seqNo.
	// stable sequence number: the number which has been verified by bft consensus module.
	stableNo uint64

	// seqNo is used for leader in synchronous bft to track the block generation, it is the next seqNo to propose.
	seqNo uint64
}

func newPartialReminder(author uint64, n int, id uint64) *partialReminder {
	return &partialReminder{
		author:           author,
		id:               id,
		quorum:           types.CalculateOneCorrect(n),
		cachedPartials:   btree.New(2),
		proposedPartials: btree.New(2),
		proposedNo:       make(map[uint64]bool),
		stableNo:         uint64(0),
		seqNo:            uint64(1),
	}
}

// pullInitiation is used to initiate the reminder to avoid duplicated partial orders.
func (pr *partialReminder) pullInitiation(proposedNo uint64) {
	if pr.seqNo == proposedNo+1 {
		return
	}

	for {
		minPartial := pr.cacheDeleteMin()

		if minPartial == nil {
			break
		}

		if minPartial.Sequence() <= proposedNo {
			// update the proposedNo
			pr.proposedNo[minPartial.Sequence()] = true

			// record the QC into proposedPartials map
			pr.proposedPartials.ReplaceOrInsert(minPartial)
			continue
		}

		pr.cachedPartials.ReplaceOrInsert(minPartial)
	}
	pr.seqNo = proposedNo+1
}

// restorePartials is used to restore the partial order from proposedPartials and remove these seqNo from proposedNo.
func (pr *partialReminder) restorePartials(tracker CommandTracker) {
	// here, we would like to restore the partial order which have a larger seqNo than the stable one in proposedPartials, which means
	// these restored partial order should be re-proposed for block generation.
	if minCached := pr.cachedMin(); minCached != nil {
		// initiate the expected sequence number, if there is a cached partial order.
		pr.seqNo = minCached.Sequence()
	}
	for {
		// get the minPartial from proposedPartials.
		minPartial := pr.proposedDeleteMin()

		// there aren't any partial order in proposedPartials, stop the restore process.
		if minPartial == nil {
			break
		}

		// the partial order with a expired seqNo do not need to be re-proposed for they have already been verified to generate a block.
		if minPartial.Sequence() <= pr.stableNo {
			continue
		}

		// restore the QC which has not been verified yet.
		pr.cachedPartials.ReplaceOrInsert(minPartial)

		// update the proposedNo map at the same time.
		delete(pr.proposedNo, minPartial.Sequence())

		// reset the tracker for commands.
		tracker.Del(minPartial.CommandDigest())

		// update the expected sequence number.
		if minPartial.Sequence() < pr.seqNo {
			pr.seqNo = minPartial.Sequence()
		}
	}
}

// insertPartial is used to store the PO (partial order) generated by current replica, we would like
// to store the partial order by btree, so that we could easily find a minPartial, and the partial order
// here should restrict the following rules:
// 1) stability: it should be larger than the stable seqNo.
// 2) availability: it should be a PO which has never been proposed yet.
func (pr *partialReminder) insertPartial(pOrder *protos.PartialOrder) error {
	if pOrder.Sequence() <= pr.stableNo {
		return fmt.Errorf("expired seqNo: stable seqNo %d, received seqNo %d", pr.stableNo, pOrder.Sequence())
	}

	if pr.isProposed(pOrder) {
		return fmt.Errorf("proposed seqNo: received seqNo %d", pOrder.Sequence())
	}

	if pOrder.Sequence() < pr.seqNo {
		pr.proposedPartials.ReplaceOrInsert(pOrder)
	} else {
		pr.cachedPartials.ReplaceOrInsert(pOrder)
	}
	return nil
}

// pullPartial is used to pull the partial order to generate the payload for bft.
func (pr *partialReminder) pullPartial() *protos.PartialOrder {
	minPartial := pr.cacheDeleteMin()

	if minPartial == nil {
		return nil
	}

	if minPartial.Sequence() != pr.seqNo {
		return nil
	}

	pr.seqNo++

	return minPartial
}

// backPartial is used to push back the QC and update the seqNo for payload generation.
func (pr *partialReminder) backPartial(pOrder *protos.PartialOrder) {
	if pOrder.Sequence() < pr.seqNo {
		pr.seqNo = pOrder.Sequence()
	}

	pr.cachedPartials.ReplaceOrInsert(pOrder)
}

// setStablePartial is used to make the verified partial order stable, in which we would like to update
// the stable seqNo and remove the expired partial order.
func (pr *partialReminder) setStablePartial(pOrder *protos.PartialOrder) error {
	// check the validation of sequence number of stableQC
	if pOrder.Sequence() != pr.stableNo+1 {
		return fmt.Errorf("invalid seqNo: expected seqNo %d, received seqNo %d", pr.stableNo+1, pOrder.Sequence())
	}

	// update the stable seqNo.
	pr.stableNo = pOrder.Sequence()

	// clear the expired cachedPartials
	for {
		minPartial := pr.cachedMin()

		if minPartial == nil {
			break
		}

		if minPartial.Sequence() > pr.stableNo {
			break
		}

		pr.cachedPartials.Delete(minPartial)
	}

	// clear the expired proposedPartials
	for {
		minPartial := pr.proposedMin()

		if minPartial == nil {
			break
		}

		if minPartial.Sequence() > pr.stableNo {
			break
		}

		pr.proposedPartials.Delete(minPartial)
	}

	return nil
}

// verify is used to check the QC from remote participates when we are running a partial-synchronized byzantine consensus.
func (pr *partialReminder) verify(author uint64, remotePartial *protos.PartialOrder) error {
	// todo we need initial data for correct stable-sequence

	// the QCBatch is generated by self, skip verification.
	if author == pr.author {
		return nil
	}

	// the remote QC shouldn't be nil.
	if remotePartial == nil {
		return errors.New("nil remote QC")
	}

	// the No of remotePartial should be sequentially increased.
	if pr.proposedNo[remotePartial.Sequence()] {
		return fmt.Errorf("proposed seqNo: reminder-ID %d, received seqNo %d", pr.id, remotePartial.Sequence())
	}

	// the signature of QC should be valid.
	if err := crypto.VerifyProofCerts(types.StringToBytes(remotePartial.Digest()), remotePartial.QC, pr.quorum); err != nil {
		return fmt.Errorf("invalid QC signature: %s", err)
	}

	return nil
}

// cachedMin is used to get the smallest QC from cache.
func (pr *partialReminder) cachedMin() *protos.PartialOrder {
	item := pr.cachedPartials.Min()

	if item == nil {
		return nil
	}

	return item.(*protos.PartialOrder)
}

// cacheDeleteMin is used to get the smallest QC from cache and delete it.
func (pr *partialReminder) cacheDeleteMin() *protos.PartialOrder {
	item := pr.cachedPartials.DeleteMin()

	if item == nil {
		return nil
	}

	return item.(*protos.PartialOrder)
}

// cachedDelete is used to delete the QC in cache.
func (pr *partialReminder) cachedDelete(qc *protos.PartialOrder) {
	pr.cachedPartials.Delete(qc)
}

func (pr *partialReminder) isProposed(qc *protos.PartialOrder) bool {
	return pr.proposedNo[qc.Sequence()]
}

func (pr *partialReminder) proposedPartial(remotePartial *protos.PartialOrder) {
	// remove the remotePartial from cache.
	pr.cachedDelete(remotePartial)

	// update the proposedNo
	pr.proposedNo[remotePartial.Sequence()] = true

	// record the QC into proposedPartials map
	pr.proposedPartials.ReplaceOrInsert(remotePartial)

	// update the sequence number.
	if pr.seqNo <= remotePartial.Sequence() {
		pr.seqNo = remotePartial.Sequence()+1
	}
}

// proposedMin is used to get the smallest QC from proposed.
func (pr *partialReminder) proposedMin() *protos.PartialOrder {
	item := pr.proposedPartials.Min()

	if item == nil {
		return nil
	}

	return item.(*protos.PartialOrder)
}

func (pr *partialReminder) proposedDeleteMin() *protos.PartialOrder {
	item := pr.proposedPartials.DeleteMin()

	if item == nil {
		return nil
	}

	return item.(*protos.PartialOrder)
}
